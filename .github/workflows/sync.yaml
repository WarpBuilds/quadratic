name: Sync
on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/10 * * * *" # Runs every 10 minutes

jobs:
  sync:
    name: Sync With Upstream
    runs-on: warp-ubuntu-latest-x64-4x
    steps:
      - uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout with GitHub App Token
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - run: |
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

      - name: Sync with upstream repository
        run: |
          # Get the upstream repository URL from GitHub API
          REPO_NAME="${GITHUB_REPOSITORY}"
          UPSTREAM_INFO=$(gh api repos/$REPO_NAME | jq -r '.parent.clone_url // empty')

          if [ -z "$UPSTREAM_INFO" ]; then
            echo "This doesn't appear to be a fork or the API couldn't retrieve the parent repository"
            exit 1
          fi

          echo "Upstream repository: $UPSTREAM_INFO"

          # Check if upstream remote exists, add it if it doesn't
          if ! git remote | grep -q "^upstream$"; then
            git remote add upstream $UPSTREAM_INFO
          else
            git remote set-url upstream $UPSTREAM_INFO
          fi

          # Fetch from upstream and origin
          git fetch upstream
          git fetch origin

          # Store current branch (typically main)
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $CURRENT_BRANCH"

          # Function to sync a branch with conflict resolution
          sync_branch() {
            local branch_name=$1
            echo "Syncing branch: $branch_name"

            # Check if we have upstream commits to sync
            BEHIND_COUNT=$(git rev-list --count HEAD..upstream/$branch_name)
            if [ "$BEHIND_COUNT" -eq 0 ]; then
              echo "Already up to date with upstream/$branch_name (no new commits to sync)"
              return 0
            fi

            echo "Found $BEHIND_COUNT commits to sync from upstream"

            # Get all workflow files currently in our repo
            WORKFLOW_DIR=".github/workflows"
            if [ -d "$WORKFLOW_DIR" ]; then
              echo "Backing up workflow files from $WORKFLOW_DIR"
              BACKUP_DIR="/tmp/workflow-backup-$(date +%s)"
              mkdir -p "$BACKUP_DIR"
              cp -r "$WORKFLOW_DIR" "$BACKUP_DIR/" || echo "Failed to backup workflow files"
            else
              echo "No workflow directory found to backup"
            fi

            # Process each commit from upstream individually
            COMMITS_TO_PICK=$(git rev-list --reverse HEAD..upstream/$branch_name)

            for COMMIT in $COMMITS_TO_PICK; do
              echo "Processing commit: $(git log -1 --pretty="%h %s" $COMMIT)"

              # Safer approach: use git diff-tree to analyze commit changes
              echo "Analyzing changes in commit $COMMIT"

              # Get files modified in the commit, specifically identifying workflow files
              ALL_CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r $COMMIT)
              WORKFLOW_FILES=$(echo "$ALL_CHANGED_FILES" | grep "^.github/workflows/" || echo "")
              NON_WORKFLOW_FILES=$(echo "$ALL_CHANGED_FILES" | grep -v "^.github/workflows/" || echo "")

              if [ -z "$NON_WORKFLOW_FILES" ]; then
                echo "Commit only changes workflow files, skipping"
                continue
              fi

              echo "This commit changes non-workflow files, applying changes"
              COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT)

              # Skip cherry-pick entirely and just apply directly with git apply
              echo "Extracting non-workflow changes from commit"

              # Create temporary directory for this operation
              TMP_DIR=$(mktemp -d)
              cd $TMP_DIR

              # Initialize a git repo to use git apply
              git init

              # Create a patch file for just the non-workflow files
              for FILE in $NON_WORKFLOW_FILES; do
                # Get the diff for this specific file from the commit
                git -C $GITHUB_WORKSPACE diff-tree -p $COMMIT -- "$FILE" > "${FILE##*/}.patch"

                if [ -s "${FILE##*/}.patch" ]; then
                  echo "Created patch for $FILE"
                else
                  echo "Warning: Empty patch for $FILE"
                fi
              done

              # Go back to workspace
              cd $GITHUB_WORKSPACE

              # Apply each patch individually
              for PATCH in $TMP_DIR/*.patch; do
                if [ -f "$PATCH" ] && [ -s "$PATCH" ]; then
                  echo "Applying patch: $PATCH"
                  if git apply --reject "$PATCH" 2>/dev/null; then
                    echo "Successfully applied patch"
                  else
                    echo "Failed to apply patch, trying with --ignore-whitespace"
                    if git apply --reject --ignore-whitespace "$PATCH" 2>/dev/null; then
                      echo "Successfully applied patch with whitespace ignored"
                    else
                      echo "Still failed to apply patch, trying with --3way"
                      # For binary files, etc., just try to copy directly
                      FILE_PATH=$(grep "^--- a/" "$PATCH" | head -1 | sed 's|^--- a/||')
                      if [ -n "$FILE_PATH" ]; then
                        echo "Trying to directly copy $FILE_PATH from commit"
                        git show "$COMMIT:$FILE_PATH" > "$FILE_PATH" 2>/dev/null || echo "Failed to extract file"
                      fi
                    fi
                  fi
                fi
              done

              # Clean up temp dir
              rm -rf $TMP_DIR

              # Stage all changes
              git add -A

              # Commit changes
              if git diff --staged --quiet; then
                echo "No changes to commit"
              else
                git commit -m "$COMMIT_MSG"
                echo "Committed changes from $COMMIT"
              fi
            done

            # Restore workflow directory
            if [ -d "$BACKUP_DIR/$WORKFLOW_DIR" ]; then
              echo "Restoring workflow files from backup"
              rm -rf "$WORKFLOW_DIR"
              mkdir -p "$(dirname "$WORKFLOW_DIR")"
              cp -r "$BACKUP_DIR/$WORKFLOW_DIR" "$(dirname "$WORKFLOW_DIR")/"

              # Commit the workflow restoration
              git add "$WORKFLOW_DIR"
              git commit -m "Restore our workflow files" || echo "No workflow changes to commit"
            fi

            # Push changes to origin if there are any
            if git rev-parse HEAD >/dev/null 2>&1 && git rev-parse origin/$branch_name >/dev/null 2>&1; then
              if [ "$(git rev-list --count origin/$branch_name..HEAD)" -gt 0 ]; then
                echo "Pushing changes to origin"
                git push origin $branch_name
              else
                echo "No changes to push"
              fi
            else
              echo "Unable to determine if changes need to be pushed"
            fi

            # Clean up
            rm -rf "$BACKUP_DIR" 2>/dev/null || true
          }

          # ----- Sync current branch -----
          sync_branch "$CURRENT_BRANCH"

          echo "Sync complete"
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
